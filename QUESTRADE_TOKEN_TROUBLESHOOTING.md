# Questrade Token Management System (Updated 2025-10-07)

## How Questrade Tokens Work

### Token Types
1. **Refresh Token** - Long-lived token for obtaining access tokens
   - Valid for 7 days from last use
   - Single-use only (each use invalidates it and provides a new one)
   - Initially obtained manually from Questrade web portal
   - Stored in `.Renviron` for bootstrapping, then managed automatically

2. **Access Token** - Short-lived token for API calls
   - Valid for 30 minutes (1800 seconds)
   - Generated by exchanging refresh token
   - **Now cached and reused** until expiration

### Token Exchange Flow (New System)
```
First Use:
.Renviron Refresh Token → Exchange → Access Token + New Refresh Token
                                      ↓                    ↓
                              Saved to ~/.investr_questrade_tokens.json
                              (includes expiration timestamp)

Subsequent Uses (within 30 min):
Read ~/.investr_questrade_tokens.json → Check expiration → Reuse Access Token
(NO API CALL - refresh token not consumed!)

After 30 min:
Cached Refresh Token → Exchange → New Access Token + New Refresh Token
                                   ↓
                            Update ~/.investr_questrade_tokens.json
```

**KEY IMPROVEMENT**: Access tokens are now cached and reused for up to 30 minutes, preventing unnecessary refresh token burns.

---

## Token Management Architecture (Updated System)

### Storage Locations

#### 1. Bootstrap Token: `/home/sergeblumenfeld/investR/.Renviron`
```
QUESTRADE_REFRESH_TOKEN=<initial_token_from_questrade>
```
- Used only for initial setup
- Read once when no cached tokens exist
- Not updated by the system (kept as backup)

#### 2. Active Token Cache: `~/.investr_questrade_tokens.json`
```json
{
  "access_token": "xyz...",
  "refresh_token": "abc...",
  "api_server": "https://api01.iq.questrade.com/",
  "expires_at": 1728345678.123,
  "saved_at": "2025-10-07 21:30:45 UTC"
}
```
- Persistent across R sessions
- Includes expiration timestamp for smart caching
- Updated automatically on each refresh

### Code Components

#### 1. Token File Management (R/utils_questrade_healthcheck.R)
**Functions:**
- `get_token_file_path()` - Returns `~/.investr_questrade_tokens.json`
- `read_token_file()` - Reads cached tokens, validates fields, converts timestamps
- `save_token_file()` - Saves new tokens with expiration timestamp
- `get_initial_refresh_token()` - Reads from `.Renviron` for bootstrap

#### 2. Smart Authentication (R/fct_questrade_api.R:27-112)
**What it does:**
1. Reads cached token from file
2. Checks if access token still valid (expires_at - 60 seconds buffer)
3. If valid → Returns cached access token (NO API CALL!)
4. If expired → Exchanges refresh token → Saves new tokens → Returns

**Logging (cached token reuse):**
```
INFO: Questrade API: Using cached access token (expires in 1234 seconds)
```

**Logging (token refresh):**
```
INFO: Questrade API: Cached access token expired or expiring soon, refreshing...
INFO: Questrade API: Exchanging refresh token (starts with e8RfBzCuNH...)
INFO: Questrade API: Token saved to ~/.investr_questrade_tokens.json
INFO: Questrade API: Access token expires at 2025-10-07 22:00:45 UTC
INFO: Questrade API: Token exchange successful, new tokens saved
```

#### 3. App Startup (R/run_app.R:71-73)
**What changed:**
- ❌ Removed background ping (not needed)
- ✅ Lazy refresh on-demand
- ✅ Tokens automatically managed per API call

---

## App Lifecycle Scenarios (New System)

### Scenario 1: First Time Setup
```
1. Get refresh token from Questrade → Save to .Renviron as QUESTRADE_REFRESH_TOKEN
2. Start app
3. First API call → Exchange refresh_token_1 → Get access_token_1 + refresh_token_2
4. Save to ~/.investr_questrade_tokens.json with expiration timestamp
5. .Renviron unchanged (still has refresh_token_1 as backup)
```
✅ **Result:** Token cache created, ready for reuse

### Scenario 2: Normal Usage (Multiple API Calls Within 30 Minutes)
```
9:00 AM - Fetch positions → Exchange token → access_token expires at 9:30 AM
9:05 AM - Fetch positions → REUSE cached access_token (still valid!)
9:15 AM - Fetch positions → REUSE cached access_token (still valid!)
9:25 AM - Fetch positions → REUSE cached access_token (still valid!)
9:35 AM - Fetch positions → Expired, exchange refresh token → new access_token
```
✅ **Result:** Only 2 API calls instead of 5 - refresh token preserved

### Scenario 3: App Restart (Same Day)
```
Morning:  Use app → access_token cached in ~/.investr_questrade_tokens.json
Shutdown: File persists
Evening:  Restart app → Read cached token → Check expiration
          - If < 30 min old: Reuse it
          - If > 30 min old: Exchange for new one
```
✅ **Works perfectly** - File-based cache survives R session restart

### Scenario 4: PC Sleep/Wake
```
Before sleep: Access token cached with expiration timestamp
During sleep: later::later() would have failed (but we don't use it anymore!)
After wake:   Read cache → Check timestamp → Refresh if expired
```
✅ **No problem** - Timestamp-based checking doesn't rely on active processes

### Scenario 5: Don't Use App for 6 Days
```
Day 1: Use app → refresh_token_A cached
...
Day 7: Use app → Read cache → refresh_token_A still valid → Exchange → Get new tokens
```
✅ **Works fine** - refresh_token_A valid for 7 days

### Scenario 6: Don't Use App for 8+ Days
```
Day 1:  Use app → refresh_token_A cached
Day 9:  Use app → Read cache → Try to exchange refresh_token_A
```
❌ **FAILS** - refresh_token_A expired (7+ days old)
```
ERROR: Questrade API: Status 400 - Refresh token is invalid or already used
ERROR: Questrade API: Generate a new token from Questrade and update .Renviron
```

**Solution:** Get fresh token from Questrade, update `.Renviron`, restart app

---

## System Improvements

### Major Overhaul (2025-10-07)

**Problem:** Daily manual token generation due to:
- `Sys.getenv()` caching preventing token updates from being seen
- Unnecessary refresh token burns on every API call
- Background ping failing during PC sleep/screensaver
- No access token reuse (30-minute tokens used only once)

**Solution: File-Based Token Caching with Lazy Refresh**

**Changes:**
1. **Token Storage:** JSON file at `~/.investr_questrade_tokens.json`
   - Stores access_token, refresh_token, api_server, expires_at timestamp
   - Persists across R sessions and PC restarts
   - No `Sys.getenv()` caching issues

2. **Smart Token Reuse:**
   - Checks expiration timestamp before each API call
   - Reuses valid access tokens (saves refresh token for later)
   - Only exchanges refresh token when access token expired
   - 60-second safety buffer prevents edge-case failures

3. **Removed Background Ping:**
   - No reliance on `later::later()` scheduler
   - No sleep/screensaver issues
   - Tokens managed on-demand per API call

**Benefits:**
- ✅ No more daily manual token generation
- ✅ Works with intermittent app usage
- ✅ Survives PC sleep, R session restarts, app restarts
- ✅ Efficient: Reuses access tokens for 30 minutes
- ✅ Refresh tokens last full 7 days between manual updates

---

## Bugs Fixed

### Bug 1: Race Condition on Background Refresh (2025-10-13)
**Location:** R/run_app.R:71-106

**Problem:**
```r
# OLD CODE (BROKEN)
refresh_questrade_activities()  # Starts immediately
refresh_questrade_positions()   # Also starts immediately
# Both processes compete for same refresh token → race condition
```
Result: Two API calls tried to use the same refresh token simultaneously, causing one to fail and corrupting the token cache.

**Fix:**
```r
# NEW CODE (FIXED - Sequential execution using promises)
refresh_questrade_activities() %...>% {
  refresh_questrade_positions()  # Only starts after activities completes
}
```
Sequential execution eliminates the race condition. Only ONE process accesses tokens at a time.

### Bug 2: Deprecated Code Causing Confusion (2025-10-13)
**Location:** R/utils_questrade_healthcheck.R

**Problem:**
- Old `ping_questrade()` function still in codebase (deprecated)
- Old `start_questrade_background_ping()` function still exported
- Old `update_refresh_token()` function that modified .Renviron
- Created confusion about which token management system was active

**Fix:**
- Deleted all deprecated functions (160 lines removed)
- Regenerated NAMESPACE to remove exports
- Cleaned up man pages
- Single clear token management approach (JSON cache only)

---

## Troubleshooting Guide

### Error: "Authentication failed with status 500"

**Meaning:** Your refresh token is invalid or already used

**Causes:**
1. Token older than 7 days
2. Token was used elsewhere (another app/script)
3. Token save failed on last rotation
4. Duplicate token usage (fixed in Bug 1)

**Solution:**
1. Get fresh token from Questrade
2. Update `.Renviron`
3. Restart R session: `readRenviron(".Renviron")`
4. Check logs for token update messages

### Error: "Failed to update refresh token"

**Meaning:** App authenticated successfully but couldn't save new token to file

**Check:**
1. `.Renviron` file exists and is writable
2. Current working directory: `getwd()`
3. File permissions: `ls -la .Renviron`
4. Check logs for "Searched: ..." message showing paths tried

**Solution:**
```r
# Verify .Renviron location
file.exists(".Renviron")                          # Should be TRUE
file.exists("~/investR/.Renviron")                # Should be TRUE

# Check permissions
Sys.info()["user"]                                # Your username
system("ls -la .Renviron")                        # Should show write permission
```

### Warning: "Token write verification failed!"

**Meaning:** File write completed but new token not found when reading back

**This is serious** - indicates file corruption or permission issues

**Solution:**
1. Manually inspect `.Renviron`: `readLines(".Renviron")`
2. Verify only ONE line with `QUESTRADE_REFRESH_TOKEN=`
3. Check for special characters or encoding issues
4. Recreate `.Renviron` if corrupted

### No Logs About Token Updates

**Meaning:** Logger level set too high or logging not enabled

**Solution:**
```r
# Set logger to show INFO and above
library(logger)
log_threshold(INFO)

# Or show everything including DEBUG
log_threshold(DEBUG)
```

---

## How to Get a Fresh Token from Questrade

1. **Log into Questrade** web portal
2. **Navigate to:** Account Settings → API Access
3. **Generate New Token:**
   - Click "Reset my token" or "Generate token"
   - Copy the token immediately (only shown once)
4. **Update .Renviron:**
   ```bash
   # Edit the file
   nano /home/sergeblumenfeld/investR/.Renviron

   # Or in R
   file.edit("/home/sergeblumenfeld/investR/.Renviron")
   ```
5. **Reload environment:**
   ```r
   readRenviron("/home/sergeblumenfeld/investR/.Renviron")
   ```
6. **Restart app** - should work immediately

---

## Expected Log Sequence on Successful Startup

```
INFO: Questrade: Background health check started (24-hour cycle)
INFO: Questrade API: Attempting authentication with token U6H1dJ1JpRyCaXm_-9-...
INFO: Questrade API: Authentication successful
INFO: Questrade: Refresh token updated successfully in /home/sergeblumenfeld/investR/.Renviron
INFO: Questrade: Old token: U6H1dJ1JpRyCaXm_-9-gB86Q... -> New token: XyZ9AbC123def456gh78...
```

If you see all these messages, token rotation is working correctly.

---

## Monitoring Token Health

### Check Current Token Age
```r
# Read .Renviron
lines <- readLines(".Renviron")
token_line <- grep("^QUESTRADE_REFRESH_TOKEN=", lines, value = TRUE)
print(token_line)

# Check file modification time (when token was last updated)
file.info(".Renviron")$mtime
```

### Test Token Manually
```r
library(httr)
token <- Sys.getenv("QUESTRADE_REFRESH_TOKEN")

response <- POST(
  "https://login.questrade.com/oauth2/token",
  query = list(
    grant_type = "refresh_token",
    refresh_token = token
  ),
  encode = "form"
)

status_code(response)  # Should be 200 if valid
```

---

## Best Practices

1. **Keep app running continuously** (if possible)
   - Deploy to server or keep local instance running
   - This ensures 24-hour rotation keeps token alive

2. **Restart at least once every 7 days** (if not running continuously)
   - Set calendar reminder for weekly restart
   - Each restart rotates the token

3. **Monitor logs on startup**
   - Look for token update success messages
   - Watch for warnings about save failures

4. **Don't reuse tokens**
   - Never copy token from `.Renviron` to another app
   - Each use invalidates it

5. **Backup strategy for production**
   - Document how to get fresh token
   - Keep Questrade login credentials accessible
   - Consider alerting if token rotation fails

---

## Quick Reference

| Timeframe | Token Status | Action Required |
|-----------|-------------|-----------------|
| < 7 days | Valid | None - auto-refresh works |
| 7+ days | Expired | Get fresh token from Questrade |
| After each use | Invalidated | New token auto-saved to .Renviron |

| Error Code | Meaning | Solution |
|------------|---------|----------|
| 500 | Invalid/expired token | Get fresh token |
| 400 | Malformed request | Check code (shouldn't happen) |
| 401 | Unauthorized | Get fresh token |
| 200 | Success | Token rotated successfully |

---

## File Locations

- **Token storage:** `/home/sergeblumenfeld/investR/.Renviron`
- **Token update logic:** `/home/sergeblumenfeld/investR/R/utils_questrade_healthcheck.R`
- **API authentication:** `/home/sergeblumenfeld/investR/R/fct_questrade_api.R`
- **App startup:** `/home/sergeblumenfeld/investR/R/run_app.R`
- **This guide:** `/home/sergeblumenfeld/investR/QUESTRADE_TOKEN_TROUBLESHOOTING.md`

---

## Emergency Checklist

If you get token errors tomorrow:

- [ ] Check error message in logs
- [ ] Verify `.Renviron` exists and contains token
- [ ] Check `.Renviron` modification time (should be recent)
- [ ] Look for "Token updated successfully" in logs
- [ ] Get fresh token from Questrade if needed
- [ ] Update `.Renviron` with fresh token
- [ ] Run `readRenviron(".Renviron")`
- [ ] Restart app
- [ ] Verify success messages in logs

---

## Quick Start After Fresh Install

1. **Get initial token from Questrade:**
   - Log into Questrade web portal
   - Navigate to: Account Settings → API Access
   - Generate new token (copy immediately)

2. **Add to `.Renviron`:**
   ```bash
   echo "QUESTRADE_REFRESH_TOKEN=<your_token_here>" >> /home/sergeblumenfeld/investR/.Renviron
   ```

3. **Start app:**
   - First API call will exchange the token
   - Creates `~/.investr_questrade_tokens.json` automatically
   - All future calls use cached tokens

4. **Normal operation:**
   - Use app anytime within 7 days → automatic token management
   - Don't use for 8+ days → Get new token from Questrade (steps 1-2)

---

**Last Updated:** 2025-10-13
**System:** File-based token caching with lazy refresh + sequential API calls
**Token Storage:** `~/.investr_questrade_tokens.json`

---

## Recent Changes (2025-10-13)

### What Was Fixed
1. **Race Condition Eliminated:** Background refreshes now run sequentially (activities → positions) using promise chains, preventing concurrent token access
2. **Dead Code Removed:** Deleted 160 lines of deprecated token management functions that were causing confusion
3. **User-Facing Alerts:** Added refresh status tracking and UI alerts on portfolio groups page to show when data refreshes fail
4. **Documentation Updated:** Fixed outdated sections to reflect actual implementation

### Expected Behavior After Fix
- Token cache file `~/.investr_questrade_tokens.json` gets created on first use
- Access tokens are reused for 30 minutes (logged as "Using cached access token")
- Refresh tokens rotate properly every 30 minutes when access tokens expire
- No more daily manual token generation needed (tokens last full 7 days)
- If refresh fails, users see clear warning message on portfolio groups page
